//------------------------------------------------------------------------
// 简称:ThreeFilter
// 名称:ThreeFilter
// 类别: 交易指令
// 类型: 用户应用
//------------------------------------------------------------------------
Params  	
	//参数定义段
	Numeric delayTimer(1);//从开仓到启动ATR棘轮之前的延迟时间
	Numeric recentHiLoWide(2);//计算初始止损点时，选取最近低点的时间段
	Numeric openSlide(1);//开仓滑点
	Numeric closeSlide(1);//平仓滑点
	Numeric atrMa(1);//通过TR计算ATR时的均线周期
	Numeric atrIndex(0.1);//将ATR转换为棘轮步长的系数
	Numeric atrType(0);//计算ATR方式，0为标准ATR，1为Barney ATR
	Numeric timeBlank(0.0903);//开始进行开仓判断的时间
	Numeric minDelta(1);//计算MACD方向时的阈值
	Numeric largePeriod(30);//第一层滤网中，长周期K线的周期
	Numeric openBreak(1);//突破开仓，当当前价位超过前一根K线+/-openBreak时开仓
GlobalVars	
	//全局变量定义段
	Numeric tradeDir(0);
	Numeric stopPrice(0);
	NumericSeries theATR;
	NumericSeries theTR;
	Numeric startBar(0);
	NumericSeries RSV;
	NumericSeries KValue;
	NumericSeries DValue;
	NumericSeries JValue;
	Numeric startPrice(0);
	Numeric endPrice(0);
	Numeric myProfit(0);
	Numeric win(0);
	Numeric lose(0);
	Numeric winStop(0);//止盈点
	Bool winFlag(False);//盈亏平衡标记
Vars		
	//局部变量定义段
	Numeric dir(0);
	Numeric tempRSV;
	Numeric tempK;
	Numeric tempD;
	Numeric tempJ;
	Numeric preClose(0);
	Numeric preHigh(0);
	Numeric preLow(0);
	Numeric lowLmt(0);
	Numeric upLmt(0);
	Numeric closePrice(0);
	Numeric sysATR(0);
	Numeric recentLo(0);
	Numeric recentHi(0);
	Numeric kAngle(0);
	Numeric opiAngle(0);
	Numeric openPoint(0);
	Numeric virtualProfit(0);//浮动收益
Begin
	//策略执行区
	//缓存序列变量，提高再次访问的效率
	closePrice = Close;
	preClose = Close[1];
	preHigh = High[1];
	preLow = Low[1];
	lowLmt = Q_LowerLimit;
	upLmt = Q_UpperLimit;
	sysATR = AvgTrueRange(atrMa);
	//近期高低点，用来设置起始止损
	recentLo = LowestFC(Low,recentHiLoWide);
	recentHi = HighestFC(High,recentHiLoWide);
	//计算ATR
	theTR = myTR();
	theATR = myATR(theTR, atrMa);
	//求KDJ
	KDJ(9, tempRSV, tempK, tempD, tempJ);
	RSV = tempRSV;
	KValue = tempK;
	DValue = tempD;
	JValue = tempJ;
	//检查价格运行方向与持仓量运行方向
	myAngle(kAngle,opiAngle, 1, 3, 0.0006, 0.001);
	//检查持仓状况
	tradeDir = MarketPosition();
	//未开仓，进行开仓逻辑
	//If(tradeDir == 0 && kAngle != opiAngle && CurrentTime > timeBlank )
	If(tradeDir == 0 && CurrentTime > timeBlank )
	{
		//dir = myMACDDir(minDelta, largePeriod);
		dir = myMADir(0, 5, 10);
		If(dir == 1)
		{
			If(RSV[1]<=20)//进入超卖区
			{
				openPoint = preHigh+openBreak*MinMove*PriceScale;
				//真实交易时，需要在此处添加限价单
				//If(Low < preHigh+1*MinMove*PriceScale && High > preHigh+1*MinMove*PriceScale)//价格覆盖过了上一根K线的顶点，此时不应有滑点
				If(High >= openPoint)
				{
					//两天内的最低价减一跳作为stopPrice
					stopPrice = recentLo - 1*MinMove*PriceScale;
					startBar = CurrentBar;
					//If(Abs(Close - stopPrice) < 10*MinMove*PriceScale)//买入价格与止损价格差值小于10跳
					{
						If(Open >= openPoint)
						{
							openPoint = Open;
						}
						startPrice = openPoint + openSlide*MinMove*PriceScale;
						PlotText(startPrice, "BUY");
						Buy(1,startPrice);
					}
				}
				
			}
		}
		If(dir == -1)
		{
			If(RSV[1]>=80)
			{
				openPoint = preLow-openBreak*MinMove*PriceScale;
				//真实交易时，需要在此处添加限价单
				//If(High > preLow-1*MinMove*PriceScale && Low < preLow-1*MinMove*PriceScale)
				If(Low <= openPoint)
				{
					stopPrice = recentHi + 1*MinMove*PriceScale;
					startBar = CurrentBar;
					//If(Abs(stopPrice - Close) < 10*MinMove*PriceScale)
					{
						If(Open <= openPoint)
						{
							openPoint = Open;
						}
						startPrice = openPoint - openSlide*MinMove*PriceScale;
						PlotText(startPrice, "SELL");
						SellShort(1,startPrice);
					}
				}
			}
		}
	}
	//买仓，进入卖平逻辑
	If(tradeDir == 1)
	{
		virtualProfit = Low[1] - startPrice - closeSlide*MinMove*PriceScale;
		If(virtualProfit>=1)
		{
			winFlag = True;//达到盈亏平衡点
		}
		If(winFlag == True)//达到盈亏平衡点之后，以上一根K的最低价作为止盈
		{
			If(Low>=Low[1])
			{
				PlotDot(Low[1], 0);
			}
			Else
			{
				//离场
				virtualProfit = 0;
				winFlag = False;
				Sell(0,0);
				endPrice = Low[1] - closeSlide*MinMove*PriceScale;
				Print("Profit: ");
				Print(endPrice - startPrice);
				myProfit = myProfit + endPrice - startPrice;
				Print("Total Profit: ");
				Print(myProfit);
				If(endPrice - startPrice > 0)
				{
					win++;
					PlotIcon(endPrice,15);
				}
				Else
				{
					lose++;
					PlotIcon(endPrice,1);
				}
				Print(win/(win+lose));
				
			}
		}
		Else If(CurrentBar - startBar > delayTimer)
		{
			//stopPrice = stopPrice + theATR[1]*theATR[1]*0.05;
			//两种不同的atr计算方法
			If(atrType == 0)
			{
				stopPrice = stopPrice + theATR[1]*atrIndex;
			}
			If(atrType == 1)
			{
				stopPrice = stopPrice + myDeltaPrice(tradeDir)*atrIndex;
			}
			PlotDot(stopPrice, 0);
		}
		If(Low<=stopPrice)//真实交易时，此处应使用Close而不是Low
		{
			//止损
			Sell(0,0);
			endPrice = stopPrice - closeSlide*MinMove*PriceScale;
			Print("Profit: ");
			Print(endPrice - startPrice);
			myProfit = myProfit + endPrice - startPrice;
			Print("Total Profit: ");
			Print(myProfit);
			If(endPrice - startPrice > 0)
			{
				win++;
				PlotIcon(endPrice,15);
			}
			Else
			{
				lose++;
				PlotIcon(endPrice,1);
			}
			Print(win/(win+lose));
		}
		
	}
	//卖仓，进入买平逻辑
	If(tradeDir == -1)
	{
		virtualProfit = startPrice - High[1] - closeSlide*MinMove*PriceScale;
		If(virtualProfit>=1)
		{
			winFlag = True;
		}
		If(winFlag == True)
		{
			If(High<=High[1])
			{
				PlotDot(High[1], 1);
			}
			Else
			{
				virtualProfit = 0;
				winFlag = False;
				BuyToCover(0,0);
				endPrice = High[1] + closeSlide*MinMove*PriceScale;
				Print("Profit: ");
				Print(startPrice - endPrice);
				myProfit = myProfit + startPrice - endPrice;
				Print("Total Profit: ");
				Print(myProfit);
				If(startPrice - endPrice > 0)
				{
					win++;
					PlotIcon(endPrice,15);
				}
				Else
				{
					lose++;
					PlotIcon(endPrice,1);
				}
				Print(win/(win+lose));
			}
		}
		Else If(CurrentBar - startBar > delayTimer)
		{
			//stopPrice = stopPrice - theATR[1]*theATR[1]*0.05;
			If(atrType == 0)
			{
				stopPrice = stopPrice - theATR[1]*atrIndex;
			}
			If(atrType == 1)
			{
				stopPrice = stopPrice + myDeltaPrice(tradeDir)*atrIndex;
			}
			If(atrType == 2)
			{
				stopPrice = High[1];
			}
			PlotDot(stopPrice, 1);
		}
		If(High>=stopPrice)//真实交易时，此处应使用Close而不是High
		{
			//止损
			BuyToCover(0,0);
			endPrice = stopPrice + closeSlide*MinMove*PriceScale;
			Print("Profit: ");
			Print(startPrice - endPrice);
			myProfit = myProfit + startPrice - endPrice;
			Print("Total Profit: ");
			Print(myProfit);
			If(startPrice - endPrice > 0)
			{
				win++;
				PlotIcon(endPrice,15);
			}
			Else
			{
				lose++;
				PlotIcon(endPrice,1);
			}
			Print(win/(win+lose));
		}
		
	}
	
End
