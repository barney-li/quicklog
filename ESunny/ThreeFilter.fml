//------------------------------------------------------------------------
// 简称:ThreeFilter
// 名称:ThreeFilter
// 类别: 交易指令
// 类型: 用户应用
//------------------------------------------------------------------------
Params  	
	//参数定义段
	Numeric trendEmaLongPeriod(14);//趋势EMA长周期 16~24
	Numeric trendEmaShortPeriod(4);//趋势EMA短周期 1
	
	Numeric overBuy(50);
	Numeric overSell(50);
	Numeric kdjPrd(9);//kdj的计算周期
	
	Numeric maxRiskPoint(30); //这笔交易可能的最大亏损
	
	Numeric cost(0.00000);//双边手续费
	Numeric minVolum(10);//最小交易单位
	
	Numeric openBreak(1);//突破开仓，当当前价位超过前一根K线+/-openBreak时开仓
	Numeric delayTimer(0);//从开仓到启动ATR棘轮之前的延迟时间
	Numeric recentHiLoWide(2);//计算初始止损点时，选取最近低点的时间段
	Numeric openSlide(1);//开仓滑点
	Numeric closeSlide(1);//平仓滑点
	Numeric atrMa(1);//通过TR计算ATR时的均线周期
	Numeric atrIndex(0.1);//将ATR转换为棘轮步长的系数
	Numeric atrType(0);//计算ATR方式，0为标准ATR，1为Barney ATR
	Numeric timeBlank(0.0903);//开始进行开仓判断的时间
	Numeric minDelta(1);//计算MACD方向时的阈值
	Numeric largePeriod(30);//MACD滤网中，长周期K线的周期
	
	
GlobalVars	
	//全局变量定义段
	Numeric tradeDir(0);//查询得到的持仓方向
	Numeric auxTradeDir(0);//若系统在历史K线有持仓的情况下进入了真实交易，那么auxTradeDir将替代tradeDir生效直到当次交易完成
	Numeric stopPrice(0);//当前K的止损位
	NumericSeries theATR;
	NumericSeries theTR;
	Numeric startBar(0);
	NumericSeries RSV;
	NumericSeries KValue;
	NumericSeries DValue;
	NumericSeries JValue;
	Numeric startPrice(0);
	Numeric endPrice(0);
	Numeric myProfit(0);
	Numeric win(0);
	Numeric lose(0);
	Numeric winStop(0);//止盈点
	Bool winFlag(False);//盈亏平衡标记
	Bool realTrade(False);//真实交易标记
	Numeric lastTradeBar(0);//最后一次交易发生的位置
	Numeric lastAtrBar(0);//最后一次计算ATR的位置
	Numeric dir(0);//趋势方向
	
Vars		
	//局部变量定义段
	
	Numeric tempRSV;
	Numeric tempK;
	Numeric tempD;
	Numeric tempJ;
	Numeric preClose(0);
	Numeric preHigh(0);
	Numeric preLow(0);
	Numeric lowLmt(0);
	Numeric upLmt(0);
	Numeric closePrice(0);
	Numeric sysATR(0);
	Numeric recentLo(0);
	Numeric recentHi(0);
	Numeric kAngle(0);
	Numeric opiAngle(0);
	Numeric openPoint(0);
	Numeric virtualProfit(0);//浮动收益
	Numeric tempVal(0);
	Numeric tempRiskPoint(0);
RealInit
	auxTradeDir = tradeDir;//将历史K线的持仓情况保存在auxTradeDir中，因为一旦进入真实交易，历史K线的持仓信息就会丢失
	realTrade = True;
Begin
	//策略执行区
	//缓存序列变量，提高再次访问的效率
	closePrice = Close;
	preClose = Close[1];
	preHigh = High[1];
	preLow = Low[1];
	lowLmt = Q_LowerLimit;
	upLmt = Q_UpperLimit;
	sysATR = AvgTrueRange(atrMa);
	//近期高低点，用来设置起始止损
	recentLo = LowestFC(Low,recentHiLoWide);
	recentHi = HighestFC(High,recentHiLoWide);
	//计算ATR
	theTR = myTR();
	theATR = myATR(theTR, atrMa);
	//求KDJ
	KDJ(kdjPrd, tempRSV, tempK, tempD, tempJ);
	RSV = tempRSV;
	KValue = tempK;
	DValue = tempD;
	JValue = tempJ;
	//检查价格运行方向与持仓量运行方向
	myAngle(kAngle,opiAngle, 1, 3, 0.0006, 0.001);
	//检查持仓状况
	tradeDir = MarketPosition();
	//计算趋势方向
	dir = myMADir(0, trendEmaShortPeriod, trendEmaLongPeriod);
	//未开仓，进行开仓逻辑
	//If(tradeDir == 0 && kAngle != opiAngle && CurrentTime > timeBlank )
	//仅在持仓为0，且交易平仓了结后（真实或模拟）才进入开仓的判断
	If(tradeDir == 0 && auxTradeDir == 0 && CurrentTime > timeBlank && lastTradeBar != CurrentBar)
	{
		//dir = myMACDDir(minDelta, largePeriod);
		
		//If(dir == 1)
		{
			If(RSV[1]<=overSell)//进入超卖区
			{
				openPoint = preHigh+openBreak*MinMove*PriceScale;
				
				If(realTrade)
				{
					dir = myMADir(0, trendEmaShortPeriod, trendEmaLongPeriod);
					tempRiskPoint = Close + openSlide*MinMove*PriceScale-(recentLo-2*openSlide*MinMove*PriceScale);
					If(Close >= openPoint && dir ==1 && tempRiskPoint<maxRiskPoint)
					{
						startBar = CurrentBar;
						startPrice = Close + openSlide*MinMove*PriceScale;
						PlotText(startPrice, "BUY");
						Buy(1,0);
						lastTradeBar = CurrentBar;
					}
				}
				Else
				{
					dir = myMADir(0, trendEmaShortPeriod, trendEmaLongPeriod,openPoint);
					tempRiskPoint = openPoint + openSlide*MinMove*PriceScale-(recentLo-2*openSlide*MinMove*PriceScale);
					If(High >= openPoint && dir==1 && tempRiskPoint<maxRiskPoint)
					{
							startBar = CurrentBar;
							If(Open >= openPoint)
							{
								openPoint = Open;
							}
							startPrice = openPoint + openSlide*MinMove*PriceScale;
							PlotText(startPrice, "BUY");
							Buy(1,startPrice);
							lastTradeBar = CurrentBar;
					}
				}
			}
		}
		//If(dir == -1)
		{
			If(RSV[1]>=overBuy)
			{
				openPoint = preLow-openBreak*MinMove*PriceScale;
				
				If(realTrade)
				{
					dir = myMADir(0, trendEmaShortPeriod, trendEmaLongPeriod);
					tempRiskPoint = (recentHi+2*openSlide*MinMove*PriceScale) - (Close - openSlide*MinMove*PriceScale);
					If(Close <= openPoint && dir == -1 && tempRiskPoint<maxRiskPoint)
					{
						startBar = CurrentBar;
						startPrice = Close - openSlide*MinMove*PriceScale;
						PlotText(startPrice, "SELL");
						SellShort(1,0);
						lastTradeBar = CurrentBar;
					}
				}
				Else
				{
					dir = myMADir(0, trendEmaShortPeriod, trendEmaLongPeriod,openPoint);
					tempRiskPoint = (recentHi+2*openSlide*MinMove*PriceScale) - (openPoint - openSlide*MinMove*PriceScale);
					If(Low <= openPoint && dir==-1 && tempRiskPoint<maxRiskPoint)
					{						
							startBar = CurrentBar;
							If(Open <= openPoint)
							{
								openPoint = Open;
							}
							startPrice = openPoint - openSlide*MinMove*PriceScale;
							PlotText(startPrice, "SELL");
							SellShort(1,startPrice);
							lastTradeBar = CurrentBar;
					}
				}
			}
		}
	}
	
	//检查持仓状况
	tradeDir = MarketPosition();
	//若在当前K的位置有开仓，那么在当前K的时段内，不断的更新初始止损位
	If(CurrentBar == lastTradeBar && tradeDir == 1)
	{
		stopPrice = recentLo - 1*MinMove*PriceScale;
	}
	If(CurrentBar == lastTradeBar && tradeDir == -1)
	{
		stopPrice = recentHi + 1*MinMove*PriceScale;
	}
	//买仓，进入卖平逻辑
	If((tradeDir == 1 || auxTradeDir == 1) && CurrentBar != lastTradeBar)
	{
		virtualProfit = Low[1] - startPrice - closeSlide*MinMove*PriceScale - minVolum*cost*Close;
		If(virtualProfit>=1)
		{
			winFlag = True;//达到盈亏平衡点
		}
		If(winFlag == True)//达到盈亏平衡点之后，以上一根K的最低价作为棘轮价格，一旦这一根K线跌破就平仓，否则在图上打个点意思一下
		{
			If(realTrade)
			{
				tempVal = Close;
			}
			Else
			{
				tempVal = Low;
			}
			If(tempVal>=Low[1])
			{
				PlotDot(Low[1], 0);
			}
			Else
			{
				//离场
				virtualProfit = 0;
				winFlag = False;
				lastTradeBar = CurrentBar;
				auxTradeDir = 0;
				If(realTrade)
				{
					endPrice = Close - closeSlide*MinMove*PriceScale;
					Sell(0,0);
				}
				Else
				{
					endPrice = Low[1] - 2*closeSlide*MinMove*PriceScale;
					Sell(0,endPrice);
				}
				//Print("Profit: ");
				//Print(endPrice - startPrice - minVolum*cost*Close);
				myProfit = myProfit + endPrice - startPrice - minVolum*cost*Close;;
				//Print("Total Profit: ");
				Print(myProfit);
				If(endPrice - startPrice - minVolum*cost*Close> 0)
				{
					win++;
					PlotIcon(endPrice,15);
				}
				Else
				{
					lose++;
					PlotIcon(endPrice,1);
				}
				Print(win/(win+lose));
				
			}
		}
		Else If((CurrentBar - startBar >= delayTimer) && lastAtrBar != CurrentBar)
		{
			//stopPrice = stopPrice + theATR[1]*theATR[1]*0.05;
			//两种不同的atr计算方法
			If(atrType == 0)
			{
				stopPrice = stopPrice + theATR[1]*atrIndex;
			}
			If(atrType == 1)
			{
				stopPrice = stopPrice + myDeltaPrice(tradeDir)*atrIndex;
			}
			If(atrType == 2)
			{
				stopPrice = Low[1];
			}
			lastAtrBar = CurrentBar;//保证每一根K线只计算一次stopPrice
			PlotDot(stopPrice, 0);
		}
		If(realTrade)
		{
			tempVal = Close;
		}
		Else
		{
			tempVal = Low;
		}
		If(tempVal<=stopPrice)//真实交易时，此处应使用Close而不是Low
		{
			//止损
			
			lastTradeBar = CurrentBar;
			auxTradeDir = 0;
			If(realTrade)
			{
				endPrice = Close - closeSlide*MinMove*PriceScale;
				Sell(0,0);
			}
			Else
			{
				endPrice = stopPrice - closeSlide*MinMove*PriceScale;
				Sell(0,endPrice);
			}
			//Print("Profit: ");
			//Print(endPrice - startPrice - minVolum*cost*Close);
			myProfit = myProfit + endPrice - startPrice - minVolum*cost*Close;
			//Print("Total Profit: ");
			Print(myProfit);
			If(endPrice - startPrice - minVolum*cost*Close> 0)
			{
				win++;
				PlotIcon(endPrice,15);
			}
			Else
			{
				lose++;
				PlotIcon(endPrice,1);
			}
			Print(win/(win+lose));
		}
		
	}
	//卖仓，进入买平逻辑
	If((tradeDir == -1 || auxTradeDir == -1) && CurrentBar != lastTradeBar)
	{
		virtualProfit = startPrice - High[1] - closeSlide*MinMove*PriceScale - minVolum*cost*Close;
		If(virtualProfit>=1)
		{
			winFlag = True;
		}
		If(winFlag == True)//达到盈亏平衡点之后，以上一根K的最高价作为棘轮价格，一旦这一根K线突破就平仓，否则在图上打个点意思一下
		{
			If(realTrade)
			{
				tempVal = Close;
			}
			Else
			{
				tempVal = High;
			}
			If(tempVal<=High[1])
			{
				PlotDot(High[1], 1);
			}
			Else
			{
				virtualProfit = 0;
				winFlag = False;
				
				lastTradeBar = CurrentBar;
				auxTradeDir = 0;
				If(realTrade)
				{
					endPrice = Close + closeSlide*MinMove*PriceScale;
					BuyToCover(0,0);
				}
				Else
				{
					endPrice = High[1] + 2*closeSlide*MinMove*PriceScale;
					BuyToCover(0,endPrice);
				}
				//Print("Profit: ");
				//Print(startPrice - endPrice - minVolum*cost*Close);
				myProfit = myProfit + startPrice - endPrice - minVolum*cost*Close;
				//Print("Total Profit: ");
				Print(myProfit);
				If(startPrice - endPrice  - minVolum*cost*Close> 0)
				{
					win++;
					PlotIcon(endPrice,15);
				}
				Else
				{
					lose++;
					PlotIcon(endPrice,1);
				}
				Print(win/(win+lose));
			}
		}
		Else If((CurrentBar - startBar >= delayTimer) && lastAtrBar != CurrentBar)
		{
			//stopPrice = stopPrice - theATR[1]*theATR[1]*0.05;
			If(atrType == 0)
			{
				stopPrice = stopPrice - theATR[1]*atrIndex;
			}
			If(atrType == 1)
			{
				stopPrice = stopPrice + myDeltaPrice(tradeDir)*atrIndex;
			}
			If(atrType == 2)
			{
				stopPrice = High[1];
			}
			lastAtrBar = CurrentBar;
			PlotDot(stopPrice, 1);
		}
		If(realTrade)
		{
			tempVal = Close;
		}
		Else
		{
			tempVal = High;
		}
		If(tempVal>=stopPrice)//真实交易时，此处应使用Close而不是High
		{
			//止损
			
			lastTradeBar = CurrentBar;
			auxTradeDir = 0;
			If(realTrade)
			{
				endPrice = Close + closeSlide*MinMove*PriceScale;
				BuyToCover(0,0);
			}
			Else
			{
				endPrice = stopPrice + closeSlide*MinMove*PriceScale;
				BuyToCover(0,endPrice);
			}
			//Print("Profit: ");
			//Print(startPrice - endPrice - minVolum*cost*Close);
			myProfit = myProfit + startPrice - endPrice - minVolum*cost*Close;
			//Print("Total Profit: ");
			Print(myProfit);
			If(startPrice - endPrice  - minVolum*cost*Close> 0)
			{
				win++;
				PlotIcon(endPrice,15);
			}
			Else
			{
				lose++;
				PlotIcon(endPrice,1);
			}
			Print(win/(win+lose));
		}
		
	}
	
End
