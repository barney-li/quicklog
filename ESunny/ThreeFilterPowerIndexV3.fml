//------------------------------------------------------------------------
// 简称:ThreeFilterPowerIndexV3
// 名称:ThreeFilterPowerIndexV3
// 类别: 交易指令
// 类型: 用户应用
//------------------------------------------------------------------------
Params  	
	//参数定义段
	Numeric trendEmaLongPeriod(14);//趋势EMA长周期 16~24
	Numeric trendEmaShortPeriod(3);//趋势EMA短周期 1
	
	Numeric powerLongPeriod(13);//劲道指数长周期 
	Numeric powerShortPeriod(3);//劲道指数短周期 1
	Numeric powerIndexExtremeLen(5);//劲道指数极值计算周期 6
	
	Numeric maxRiskPoint(50); //这笔交易可能的最大亏损
	
	Numeric shares(1);//交易量
	
	Numeric cost(0.00000);//双边手续费
	Numeric minVolum(10);//最小交易单位
	
	Numeric openBreak(1);//突破开仓，当当前价位超过前一根K线+/-openBreak时开仓
	Numeric recentHiLoWide(2);//计算初始止损点时，选取最近低点的时间段
	Numeric openSlide(1);//开仓滑点
	Numeric closeSlide(1);//平仓滑点
	Numeric atrMa(1);//通过TR计算ATR时的均线周期
	Numeric atrIndex(0.1);//将ATR转换为棘轮步长的系数
	Numeric timeBlank(0.0903);//开始进行开仓判断的时间
	
GlobalVars	
	//全局变量定义段
	Numeric tradeDir(0);//查询得到的持仓方向
	Numeric auxTradeDir(0);//若系统在历史K线有持仓的情况下进入了真实交易，那么auxTradeDir将替代tradeDir生效直到当次交易完成
	Numeric stopPrice(0);//当前K的止损位
	NumericArray theATR;
	NumericArray theTR;
	Numeric startPrice(0);
	Numeric endPrice(0);
	NumericArray powerShortEMA;
	NumericArray powerLongEMA;
	NumericArray powerVal;
	Bool winFlag(False);//盈亏平衡标记
	Bool realTrade(False);//真实交易标记
	Numeric win(0);
	Numeric lose(0);
	Numeric dir(0);//趋势方向
	NumericArray hrVol;
	NumericArray hrClose;
	NumericArray hrHi;
	NumericArray hrLo;
	Numeric lastTradeDate(0);//最近一次交易的日期
	Numeric lastTradeHour(0);//最近一次交易的小时
	Numeric lastAtrDate(0);//最后一次计算ATR的日期
	Numeric lastAtrHour(0);//最后一次计算ATR的小时
	Numeric lastSerializeMin(0);
RealInit	
	//在模拟交易切换到真实交易时调用该段
	auxTradeDir = tradeDir;//将历史K线的持仓情况保存在auxTradeDir中，因为一旦进入真实交易，历史K线的持仓信息就会丢失
	realTrade = True;
	
Vars		
	//局部变量定义段
	Numeric recentLo(0);
	Numeric recentHi(0);
	Numeric openPoint(0);
	Numeric virtualProfit(0);//浮动收益
	Numeric tempVal(0);
	Numeric recentHiPowerIndex(0);
	Numeric recentLoPowerIndex(0);
	Numeric tempRiskPoint(0);
	NumericArray tempArray;
	Numeric myProfit(0);
Begin
	//策略执行区

	//持续更新所有需要按小时bar回溯的array
	If(lastSerializeMin != Minute)
	{
		myArraySerialize(powerVal);
		myArraySerialize(powerShortEMA);
		myArraySerialize(powerLongEMA);
		myArraySerialize(hrVol);
		myArraySerialize(hrClose);
		myArraySerialize(hrHi);
		myArraySerialize(hrLo);
		myArraySerialize(theTR);
		myArraySerialize(theATR);
		lastSerializeMin = Minute;
	}
	tempArray = HisData(Enum_Data_Vol, Enum_Period_Min60, "", 1);
	hrVol[0] = tempArray[0];
	tempArray = HisData(Enum_Data_Close, Enum_Period_Min60, "", 1);
	hrClose[0] = tempArray[0];
	tempArray = HisData(Enum_Data_High, Enum_Period_Min60, "", 1);
	hrHi[0] = tempArray[0];
	tempArray = HisData(Enum_Data_Low, Enum_Period_Min60, "", 1);
	hrLo[0] = tempArray[0];

	powerVal[0] = myPowerIndex(hrVol[0], hrClose[0], hrClose[1]);
	myXAverage(powerval[0], powerShortEMA, powerShortPeriod);
	myXAverage(powerVal[0], powerLongEMA, powerLongPeriod);
	recentHiPowerIndex = myArrExtremes(powerShortEMA, true, powerIndexExtremeLen);
	recentLoPowerIndex = myArrExtremes(powerShortEMA, False, powerIndexExtremeLen);
	Print(hrVol[0]);
	recentLo = myArrExtremes(hrLo, False, recentHiLoWide);
	recentHi = myArrExtremes(hrHi, True, recentHiLoWide);
	
	theTR[0] = myTR_Array(hrHi, hrLo, hrClose);
	theATR[0] = myATR_Array(theTR, atrMa);
	
	tradeDir = MarketPosition();
	dir = myMADir(0,trendEmaShortPeriod,trendEmaLongPeriod,Close);

	If(tradeDir == 0 && auxTradeDir == 0 && CurrentTime > timeBlank && myNewHour(lastTradeDate, lastTradeHour) )
	{	
		If(dir == 1)
		{	
			If(powerShortEMA[0]>0 && powerShortEMA[0] == recentHiPowerIndex)
			{
				openPoint = hrHi[1]+openBreak*MinMove*PriceScale;
				tempRiskPoint = Close + openSlide*MinMove*PriceScale-(recentLo-2*openSlide*MinMove*PriceScale);
				If(Close >= openPoint && tempRiskPoint<maxRiskPoint)
				{
					startPrice = Close + openSlide*MinMove*PriceScale;
					PlotText(startPrice, "BUY");
					Buy(shares,0);
					lastTradeDate = Date;
					lastTradeHour = Hour;
				}
			}
		}
		
		If(dir == -1)
		{	
			If(powerShortEMA[0]<0 && powerShortEMA[0] == recentLoPowerIndex)
			{	
				openPoint = hrLo[1]-openBreak*MinMove*PriceScale;
				tempRiskPoint = (recentHi+2*openSlide*MinMove*PriceScale) - (Close - openSlide*MinMove*PriceScale);
				If(Close <= openPoint && tempRiskPoint<maxRiskPoint)
				{
					startPrice = Close - openSlide*MinMove*PriceScale;
					PlotText(startPrice, "SELL");
					SellShort(shares,0);
					lastTradeDate = Date;
					lastTradeHour = Hour;
				}
			}	
		}
	}
	
	//检查持仓状况
	tradeDir = MarketPosition();
	//若在当前K的位置有开仓，那么在当前K的时段内，不断的更新初始止损位
	If(!myNewHour(lastTradeDate, lastTradeHour) && tradeDir == 1)
	{
		stopPrice = recentLo - 1*MinMove*PriceScale;
		PlotDot(stopPrice, 0);
	}
	If(!myNewHour(lastTradeDate, lastTradeHour) && tradeDir == -1)
	{
		stopPrice = recentHi + 1*MinMove*PriceScale;
		PlotDot(stopPrice, 1);
	}
	
	//买仓，进入卖平逻辑
	If((tradeDir == 1 || auxTradeDir == 1) && myNewHour(lastTradeDate, lastTradeHour))
	{
		virtualProfit = hrLo[1] - startPrice - closeSlide*MinMove*PriceScale - minVolum*cost*Close;
		If(virtualProfit>=1)
		{
			winFlag = True;//达到盈亏平衡点
		}
		If(winFlag == True)//达到盈亏平衡点之后，以上一根K的最低价作为棘轮价格，一旦这一根K线跌破就平仓，否则在图上打个点意思一下
		{
			tempVal = IIF(realTrade, Close, Low);
			If(tempVal>=hrLo[1])
			{
				PlotDot(hrLo[1], 0);
			}
			Else
			{
				//离场
				virtualProfit = 0;
				winFlag = False;
				lastTradeDate = Date;
				lastTradeHour = Hour;
				auxTradeDir = 0;
				If(realTrade)
				{
					endPrice = Close - closeSlide*MinMove*PriceScale;
					Sell(shares,0);
				}
				Else
				{
					endPrice = hrLo[1] - 2*closeSlide*MinMove*PriceScale;
					Sell(shares,endPrice);
				}
				myProfit = myProfit + endPrice - startPrice - minVolum*cost*Close;
				Print(myProfit);
				If(endPrice - startPrice - minVolum*cost*Close> 0)
				{
					win++;
					PlotIcon(endPrice,15);
				}
				Else
				{
					lose++;
					PlotIcon(endPrice,1);
				}
				Print(win/(win+lose));
			}
		}
		Else 
		{
			If(myNewHour(lastAtrDate, lastAtrHour))
			{
				stopPrice = stopPrice + theATR[1]*atrIndex;
				lastAtrDate = Date;//保证每小时只计算一次stopPrice
				lastAtrHour = Hour;
			}
			PlotDot(stopPrice, 0);
		}
		tempVal = IIF(realTrade, Close, Low);
		If(tempVal<=stopPrice)//真实交易时，此处应使用Close而不是Low
		{
			//止损
			lastTradeDate = Date;
			lastTradeHour = Hour;
			auxTradeDir = 0;
			If(realTrade)
			{
				endPrice = Close - closeSlide*MinMove*PriceScale;
				Sell(shares,0);
			}
			Else
			{
				endPrice = stopPrice - closeSlide*MinMove*PriceScale;
				Sell(shares,endPrice);
			}
			myProfit = myProfit + endPrice - startPrice - minVolum*cost*Close;
			Print(myProfit);
			If(endPrice - startPrice - minVolum*cost*Close> 0)
			{
				win++;
				PlotIcon(endPrice,15);
			}
			Else
			{
				lose++;
				PlotIcon(endPrice,1);
			}
			Print(win/(win+lose));
		}
		
	}
	
	//卖仓，进入买平逻辑
	If((tradeDir == -1 || auxTradeDir == -1) && myNewHour(lastTradeDate, lastTradeHour))
	{
		virtualProfit = startPrice - hrHi[1] - closeSlide*MinMove*PriceScale - minVolum*cost*Close;
		If(virtualProfit>=1)
		{
			winFlag = True;
		}
		If(winFlag == True)//达到盈亏平衡点之后，以上一根K的最高价作为棘轮价格，一旦这一根K线突破就平仓，否则在图上打个点意思一下
		{
			tempVal = IIF(realTrade, Close, High);
			If(tempVal<=hrHi[1])
			{
				PlotDot(hrHi[1], 1);
			}
			Else
			{
				virtualProfit = 0;
				winFlag = False;
				lastTradeDate = Date;
				lastTradeHour = Hour;
				auxTradeDir = 0;
				If(realTrade)
				{
					endPrice = Close + closeSlide*MinMove*PriceScale;
					BuyToCover(shares,0);
				}
				Else
				{
					endPrice = hrHi[1] + 2*closeSlide*MinMove*PriceScale;
					BuyToCover(shares,endPrice);
				}
				myProfit = myProfit + startPrice - endPrice - minVolum*cost*Close;
				Print(myProfit);
				If(startPrice - endPrice  - minVolum*cost*Close> 0)
				{
					win++;
					PlotIcon(endPrice,15);
				}
				Else
				{
					lose++;
					PlotIcon(endPrice,1);
				}
				Print(win/(win+lose));
			}
		}
		Else
		{
			If(myNewHour(lastAtrDate, lastAtrHour))
			{
				stopPrice = stopPrice - theATR[1]*atrIndex;
				lastAtrDate = Date;
				lastAtrHour = Hour;
			}
			PlotDot(stopPrice, 1);
		}
		tempVal = IIF(realTrade, Close, High);
		If(tempVal>=stopPrice)//真实交易时，此处应使用Close而不是High
		{
			//止损
			lastTradeDate = Date;
			lastTradeHour = Hour;
			auxTradeDir = 0;
			If(realTrade)
			{
				endPrice = Close + closeSlide*MinMove*PriceScale;
				BuyToCover(shares,0);
			}
			Else
			{
				endPrice = stopPrice + closeSlide*MinMove*PriceScale;
				BuyToCover(shares,endPrice);
			}
			myProfit = myProfit + startPrice - endPrice - minVolum*cost*Close;
			Print(myProfit);
			If(startPrice - endPrice  - minVolum*cost*Close> 0)
			{
				win++;
				PlotIcon(endPrice,15);
			}
			Else
			{
				lose++;
				PlotIcon(endPrice,1);
			}
			Print(win/(win+lose));
		}
		
	}
End
