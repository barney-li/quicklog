//------------------------------------------------------------------------
// 简称:ThreeFilterReverse
// 名称:ThreeFilterReverse
// 类别: 交易指令
// 类型: 用户应用
//------------------------------------------------------------------------
Params  	
	//参数定义段
	Numeric delayTimer(1);//从开仓到启动ATR棘轮之前的延迟时间
	Numeric recentHiLoWide(2);//计算初始止损点时，选取最近低点的时间段
	Numeric openSlide(1);//开仓滑点
	Numeric closeSlide(1);//平仓滑点
	Numeric atrMa(1);//通过TR计算ATR时的均线周期
	Numeric atrIndex(0.1);//将ATR转换为棘轮步长的系数
	Numeric atrType(0);//计算ATR方式，0为标准ATR，1为Barney ATR
	Numeric timeBlank(0.0903);//开始进行开仓判断的时间
	Numeric timeBlank1(0.1455);//停止开仓的时间
	Numeric minDelta(1);//计算MACD方向时的阈值
	Numeric largePeriod(30);//第一层滤网中，长周期K线的周期
	Numeric openBreak(1);//突破开仓，当当前价位超过前一根K线+/-openBreak时开仓
	Numeric fixedProfit(2);//固定收益，达到收益即平仓
	Numeric fixedStop(2);//固定止损，达到即平仓
GlobalVars	
	//全局变量定义段
	Numeric tradeDir(0);
	Numeric stopPrice(0);
	NumericSeries theATR;
	NumericSeries theTR;
	Numeric startBar(0);
	NumericSeries RSV;
	NumericSeries KValue;
	NumericSeries DValue;
	NumericSeries JValue;
	Numeric startPrice(0);
	Numeric endPrice(0);
	Numeric myProfit(0);
	Numeric win(0);
	Numeric lose(0);
Vars		
	//局部变量定义段
	Numeric dir(0);
	Numeric tempRSV;
	Numeric tempK;
	Numeric tempD;
	Numeric tempJ;
	Numeric preClose(0);
	Numeric preHigh(0);
	Numeric preLow(0);
	Numeric lowLmt(0);
	Numeric upLmt(0);
	Numeric closePrice(0);
	Numeric sysATR(0);
	Numeric recentLo(0);
	Numeric recentHi(0);
	Numeric kAngle(0);
	Numeric opiAngle(0);
	Numeric openPoint(0);
	Numeric sellAtPrice(0);//止盈点
Begin
	//策略执行区
	//缓存序列变量，提高再次访问的效率
	closePrice = Close;
	preClose = Close[1];
	preHigh = High[1];
	preLow = Low[1];
	lowLmt = Q_LowerLimit;
	upLmt = Q_UpperLimit;
	sysATR = AvgTrueRange(atrMa);
	//近期高低点，用来设置起始止损
	recentLo = LowestFC(Low,recentHiLoWide);
	recentHi = HighestFC(High,recentHiLoWide);
	//计算ATR
	theTR = myTR();
	theATR = myATR(theTR, atrMa);
	//求KDJ
	KDJ(9, tempRSV, tempK, tempD, tempJ);
	RSV = tempRSV;
	KValue = tempK;
	DValue = tempD;
	JValue = tempJ;
	//检查价格运行方向与持仓量运行方向
	myAngle(kAngle,opiAngle, 1, 3, 0.0006, 0.001);
	//检查持仓状况
	tradeDir = MarketPosition();
	//未开仓，进行开仓逻辑
	//If(tradeDir == 0 && kAngle != opiAngle && CurrentTime > timeBlank )
	If(tradeDir == 0 && CurrentTime > timeBlank && CurrentTime < timeBlank1)
	{
		//dir = myMACDDir(minDelta, largePeriod);
		dir = myMADir(0, 5, 10);
		If(dir == 1)
		{
			If(RSV[1]<=30)//进入超卖区
			{
				openPoint = preHigh+openBreak*MinMove*PriceScale;
				//真实交易时，需要在此处添加限价单
				//If(Low < preHigh+1*MinMove*PriceScale && High > preHigh+1*MinMove*PriceScale)//价格覆盖过了上一根K线的顶点，此时不应有滑点
				If(High >= openPoint)
				{
					//两天内的最低价减一跳作为stopPrice
					stopPrice = recentLo - 1*MinMove*PriceScale;
					startBar = CurrentBar;
					If(Open >= openPoint)
					{
						openPoint = Open;
					}
					startPrice = openPoint - openSlide*MinMove*PriceScale;
					PlotText(startPrice, "SELL");
					SellShort(1,startPrice);
					
				}
				
			}
		}
		If(dir == -1)
		{
			If(RSV[1]>=70)
			{
				openPoint = preLow-openBreak*MinMove*PriceScale;
				//真实交易时，需要在此处添加限价单
				//If(High > preLow-1*MinMove*PriceScale && Low < preLow-1*MinMove*PriceScale)
				If(Low <= openPoint)
				{
					stopPrice = recentHi + 1*MinMove*PriceScale;
					startBar = CurrentBar;
					If(Open <= openPoint)
					{
						openPoint = Open;
					}
					startPrice = openPoint + openSlide*MinMove*PriceScale;
					PlotText(startPrice, "BUY");
					Buy(1,startPrice);
				}
			}
		}
	}
	//买仓，进入卖平逻辑
	If(tradeDir == 1)
	{
		PlotDot(Close,0);
/*		If(CurrentBar - startBar < 7)
		{
			If(High - startPrice >= fixedProfit*MinMove*PriceScale)
			{
				win++;
				Print(win/(win+lose));
				Sell(0,0);
			}
		}
		Else
		{
			lose++;
			Print(win/(win+lose));
			Sell(0,0);
		}*/
		If(High>=startPrice + fixedProfit*MinMove*PriceScale)
		{
			PlotIcon(startPrice + fixedProfit*MinMove*PriceScale - 1, 15);
			myProfit = myProfit + fixedProfit*MinMove*PriceScale - 1;
			Print("My Profit: ");
			Print(myProfit);
			win++;
			Print(win/(win+lose));
			Sell(0,0);
		}
		Else If(Low<=startPrice - fixedStop*MinMove*PriceScale)
		{
			
			/*PlotIcon(startPrice - fixedStop*MinMove*PriceScale - 1, 1);
			myProfit = myProfit - fixedStop*MinMove*PriceScale - 1;
			Print("My Profit: ");
			Print(myProfit);
			lose++;
			Print(win/(win+lose));
			Sell(0,0);*/
			//另一种情况，若盘中出现了最低点低于止损价，就在收盘时平仓
			PlotIcon(Close,1);
			myProfit = myProfit + Close - startPrice - 1;
			Print("My Profit: ");
			Print(myProfit);
			lose++;
			Print(win/(win+lose));
			Sell(0,0);
		}
		Else If(CurrentTime >=0.1455)//不持隔夜仓
		{
			PlotIcon(Close,1);
			myProfit = myProfit + Close - startPrice - 1;
			Print("My Profit: ");
			Print(myProfit);
			lose++;
			Print(win/(win+lose));
			Sell(0,0);
		}
		
	}
	//卖仓，进入买平逻辑
	If(tradeDir == -1)
	{
		PlotDot(Close,1);
		/*If(CurrentBar - startBar < 7)
		{
			If(startPrice - Low >= fixedProfit*MinMove*PriceScale)
			{
				win++;
				Print(win/(win+lose));
				BuyToCover(0,0);
			}
		}
		Else
		{
			lose++;
			Print(win/(win+lose));
			BuyToCover(0,0);
		}*/
		If(Low<=startPrice + fixedProfit*MinMove*PriceScale)
		{
			PlotIcon(startPrice - fixedProfit*MinMove*PriceScale + 1, 15);
			myProfit = myProfit + fixedProfit*MinMove*PriceScale - 1;
			Print("My Profit: ");
			Print(myProfit);
			win++;
			Print(win/(win+lose));
			BuyToCover(0,0);
		}
		Else If(High>=startPrice + fixedStop*MinMove*PriceScale)
		{
			
			/*PlotIcon(startPrice + fixedStop*MinMove*PriceScale + 1, 1);
			myProfit = myProfit - fixedStop*MinMove*PriceScale - 1;
			Print("My Profit: ");
			Print(myProfit);
			lose++;
			Print(win/(win+lose));
			BuyToCover(0,0);*/
			//另一种情况
			PlotIcon(Close,1);
			myProfit = myProfit + startPrice - Close - 1;
			Print("My Profit: ");
			Print(myProfit);
			lose++;
			Print(win/(win+lose));
			BuyToCover(0,0);
		}
		Else If(CurrentTime >=0.1455)//不持隔夜仓
		{
			PlotIcon(Close,1);
			myProfit = myProfit + startPrice - Close - 1;
			Print("My Profit: ");
			Print(myProfit);
			lose++;
			Print(win/(win+lose));
			BuyToCover(0,0);
		}
		
	}
	
End
