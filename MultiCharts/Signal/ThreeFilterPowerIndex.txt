inputs: 
	trendEmaLongPeriod(14),// trend EMA long period
	trendEmaShortPeriod(5), // trend EMA short period
	minDelta(9),// threshold by exceeding which a trend could be recognized
	
	powerLongPeriod(12), // power index EMA long period
	powerShortPeriod(1), // power index EMA short period
	powerIndexExtremeLen(5), // power index EMA extreme period
	
	maxRiskPoint(50),// max possible lose
	tradeShares(1),// trade shares
	
	cost(0),// cost rate
	minVolumn(10),// min trade amount
	
	realTrade(false),
	
	timeBlank(903),
	openBreak(1),
	recentHiLoWide(2),// recent hi/lo period
	slide(1),// open slide
	atrIndex(0.1),// the coefficient that translate atr into price
	atrMa(1),// ATR MA period
	
	existingPosition(0),// can specify existing position before 
	existingEntryPrice(0);// can specify existing entry price

vars:
	intrabarpersist tradeDir(0),
	intrabarpersist auxTradeDir(0),
	intrabarpersist stopPrice(0),
	intrabarpersist startPrice(0),
	intrabarpersist endPrice(False),
	intrabarpersist winFlag(False),
	intrabarpersist win(0),
	intrabarpersist lose(0),
	intrabarpersist dir(0),
	intrabarpersist lastTradeDate(0),
	intrabarpersist lastTradeHour(0),
	intrabarpersist lastAtrHour(0),
	intrabarpersist lastAtrDate(0),
	intrabarpersist lastSerializeMin(0),
	intrabarpersist dayBarIndex(10),
	intrabarpersist hrBarIndex(0),
	intrabarpersist recentLo(0),
	intrabarpersist recentHi(0),
	intrabarpersist openPoint(0),
	intrabarpersist virtualProfit(0),
	intrabarpersist tempVal(0),
	intrabarpersist recentHiPowerIndex(0),
	intrabarpersist recentLoPowerIndex(0),
	intrabarpersist tempRiskPoint(0),
	intrabarpersist myProfit(0);
array: 
	intrabarpersist fastDayMA[1000](close),
	intrabarpersist slowDayMA[1000](close),
	intrabarpersist dayClose[1000](close),
	intrabarpersist dayHi[1000](0),
	intrabarpersist dayLo[1000](999999),
	intrabarpersist powerShortEma[5000](0), 
	intrabarpersist powerLongEma[5000](0),
	intrabarpersist powerVal[5000](0),
	intrabarpersist theATR[5000](0),
	intrabarpersist theTR[5000](0),
	intrabarpersist hrClose[5000](0),
	intrabarpersist hrHi[5000](0),
	intrabarpersist hrLo[5000](999999),
	intrabarpersist hrVol[5000](0);

begin
	[ProcessMouseEvents = True];
	[IntrabarOrderGeneration = False];

	myGetDayIndex(daybarindex);
	myGetDayData(dayClose, dayHi, dayLo, dayBarIndex);
	
	myGetHrIndex(hrBarIndex);	
	myGetHrData(hrClose, hrHi, hrLo, hrVol, hrBarIndex);
	
	powerVal[hrBarIndex] = myPowerIndex(hrVol[hrBarindex], hrClose[hrBarIndex], hrClose[hrBarIndex-1]);
	myXAverage(powerVal[hrBarIndex], powerShortPeriod, hrBarIndex, powerShortEma);
	myXAverage(powerVal[hrBarIndex], powerLongPeriod, hrBarIndex, powerLongEma);
	
	recentHiPowerIndex = myExtremesArray(powerShortEma, hrBarIndex, true, powerIndexExtremeLen);
	recentLoPowerIndex = myExtremesArray(powerShortEma, hrBarIndex, false, powerIndexExtremeLen);
	
	recentHi = myExtremesArray(hrHi, hrBarIndex, true, recentHiLoWide);
	recentLo = myExtremesArray(hrLo, hrBarIndex, false, recentHiLoWide);
	
	theTR[hrBarIndex] = myTR(hrHi, hrLo, hrClose, hrBarIndex);
	myXAverage(theTR[hrBarIndex], atrMa, hrBarIndex, theATR);
	
	dir = myMADir(dayClose[dayBarIndex], trendEmaShortPeriod, trendEmaLongPeriod, mindelta, fastDayMA, slowDayMA, dayBarIndex);
	
	tradeDir = marketposition();
	
	//will not open twice in a same hour bar
	if tradeDir = 0 and Time > timeBlank and lastTradeHour < hrBarIndex then
	begin
		if dir = 1 and powerShortEma[hrBarIndex]>0 and powerShortEma[hrBarIndex] = recentHiPowerIndex then
		begin
			openPoint = hrHi[hrBarIndex-1]+openBreak*MinMove/PriceScale;
			tempRiskPoint = Close + slide*MinMove/PriceScale - (recentLo-2*slide*MinMove/PriceScale);
			if Close >= openPoint and tempRiskPoint<maxRiskPoint then // we could try cross over here
			begin
				buy tradeShares share at next bar at market;
				lastTradeHour = hrBarIndex;
			end;
		end;
		
		if dir = -1 and powerShortEma[hrBarIndex]<0 and powerShortEma[hrBarIndex] = recentLoPowerIndex then
		begin
			openPoint = hrLo[hrBarIndex-1]-openBreak*MinMove/PriceScale;
			tempRiskPoint = recentHi+2*slide*MinMove/PriceScale - (Close-slide*MinMove/PriceScale);
			if Close <= openPoint and tempRiskPoint<maxRiskPoint then
			begin
				sellshort tradeShares share at next bar at market;
				lastTradeHour = hrBarIndex;
			end;
		end;
	end;
	
	// updating stop price when it's in the same hour har
	if lastTradeHour=hrBarIndex and tradeDir=1 then
	begin
		stopPrice = recentLo - 1*MinMove/PriceScale; 
		//Arw_New (date, time, stopPrice, true); 
	end;
	if lastTradeHour=hrbarindex and tradeDir=-1 then
	begin
		stopPrice = recentHi + 1*MinMove/PriceScale;
		//Arw_New (date, time, stopPrice, false);
	end;
	
	// check market position
	tradeDir = marketposition;
	// check entry price
	startPrice = avgentryprice;
	
	// sell close judge
	if tradeDir=1 and startPrice<>0 and lastTradeHour<hrBarIndex then
	begin
		virtualProfit = hrLo[hrBarIndex-1] - slide*MinMove/PriceScale - startPrice;
		if virtualProfit>=0 then winFlag = true;
		if winFlag = true then
		begin
			// if still making money
			if Close>= hrLo[hrBarIndex-1] then tl_new(date, floor(time/100)*100, hrLo[hrBarIndex-1], date, time, hrLo[hrBarIndex-1])
			else // otherwise get out
			begin
				winFlag=False;
				lastTradeHour=hrBarIndex;
				sell("stop win sell") at next bar at market;
			end;
		end
		else // if it did not make any profit yet, calculate stop lose point
		begin
			if lastAtrHour<hrBarIndex then 
			begin
				stopPrice=stopPrice+theATR[hrBarIndex-1]*atrIndex;
				lastAtrHour=hrBarIndex;
			end;
			tl_new(date, floor(time/100)*100, stopPrice, date, time, stopPrice);
		end;
		// stop lose judge
		if close <= stopPrice then
		begin
			winFlag=False;
			lastTradeHour = hrBarIndex;
			sell("stop lose sell") at next bar at market;
		end;
	end;
	
	// buy to cover close
	if tradeDir=-1 and startPrice<>0 and lastTradeHour<hrBarIndex then
	begin
		virtualProfit = startPrice - hrHi[hrBarIndex-1] - slide*MinMove/PriceScale;
		if virtualProfit>=0 then winFlag = true;
		if winFlag = true then
		begin
			// if still making money
			if Close <= hrHi[hrBarIndex-1] then tl_new(date, floor(time/100)*100, hrHi[hrBarIndex-1], date, time, hrHi[hrBarIndex-1])
			else // otherwise get out
			begin
				winFlag=False;
				lastTradeHour=hrBarIndex;
				buytocover("stop win buy") at next bar at market;
			end;
		end
		else // if it did not make any profit yet, calculate stop lose point
		begin
			if lastAtrHour<hrBarIndex then 
			begin
				stopPrice=stopPrice-theATR[hrBarIndex-1]*atrIndex;
				lastAtrHour=hrBarIndex;
			end;
			tl_new(date, floor(time/100)*100, stopPrice, date, time, stopPrice);
		end;
		// stop lose judge
		if Close >= stopPrice then
		begin
			winFlag=False;
			lastTradeHour = hrBarIndex;
			buytocover("stop lose buy") at next bar at market;
		end;
	end;
	
	// safety net
	if tradeDir=1  and lastTradeHour>=hrBarIndex and startPrice-Close>maxRiskPoint then sell("safety net sell") at next bar at market;
	if tradeDir=-1 and lastTradeHour>=hrBarIndex and Close-startPrice>maxRiskPoint then buytocover("safety net buy") at next bar at market;
end
	
