inputs: 
	trendEmaLongPeriod(15),// trend EMA long period
	trendEmaShortPeriod(2), // trend EMA short period
	minDelta(10),// threshold by exceeding which a trend could be recognized
	
	powerLongPeriod(12), // power index EMA long period
	powerShortPeriod(5), // power index EMA short period
	powerIndexExtremeLen(5), // power index EMA extreme period
	
	maxRiskPoint(50),// max possible lose
	tradeShares(1),// trade shares
	
	cost(0),// cost rate
	minVolumn(10),// min trade amount
	
	realTrade(false),
	
	timeBlank(903),
	openBreak(1),
	recentHiLoWide(2),// recent hi/lo period
	slide(1),// open slide
	atrIndex(0.1),// the coefficient that translate atr into price
	atrMa(1),// ATR MA period
	
	logSwitch(True),// enable or disable log
	
	existingTrade(false),
	existinglastTradeIndex(0),// can specify existing trade bar index
	existingTradeDir(0),// can specify existing position before 
	existingStartPrice(0);// can specify existing entry price

vars:
	intrabarpersist last10mStart(0),
	intrabarpersist newExtremeCnt(0),
	intrabarpersist unfinishedTrade(existingTrade),
	intrabarpersist tradeDir(existingTradeDir),
	intrabarpersist auxTradeDir(0),
	intrabarpersist stopPrice(0),
	intrabarpersist startPrice(existingStartPrice),
	intrabarpersist endPrice(False),
	intrabarpersist winFlag(False),
	intrabarpersist win(0),
	intrabarpersist lose(0),
	intrabarpersist dir(0),
	intrabarpersist lastTradeDate(0),
	intrabarpersist lastTradeIndex(existinglastTradeIndex),
	intrabarpersist lastAtrHour(0),
	intrabarpersist lastAtrDate(0),
	intrabarpersist lastSerializeMin(0),
	intrabarpersist dayBarIndex(10),
	intrabarpersist hrBarIndex(0),
	intrabarpersist m10BarIndex(0),
	intrabarpersist recentLo(0),
	intrabarpersist recentHi(0),
	intrabarpersist openPoint(0),
	intrabarpersist virtualProfit(0),
	intrabarpersist tempVal(0),
	intrabarpersist recentHiPowerIndex(0),
	intrabarpersist recentLoPowerIndex(0),
	intrabarpersist tempRiskPoint(0),
	intrabarpersist myProfit(0),
	intrabarpersist logEnable(logSwitch);
array: 
	intrabarpersist fastDayMA[1000](close),
	intrabarpersist slowDayMA[1000](close),
	intrabarpersist dayOpen[1000](close),
	intrabarpersist dayClose[1000](close),
	intrabarpersist dayHi[1000](0),
	intrabarpersist dayLo[1000](999999),
	intrabarpersist powerShortEma[30000](0), 
	intrabarpersist powerLongEma[30000](0),
	intrabarpersist powerVal[30000](0),
	intrabarpersist theATR[30000](0),
	intrabarpersist theTR[30000](0),
	intrabarpersist m10Close[30000](0),
	intrabarpersist m10Hi[30000](0),
	intrabarpersist m10Lo[30000](0),
	intrabarpersist m10Vol[30000](0),
	intrabarpersist hrClose[30000](0),
	intrabarpersist hrHi[30000](0),
	intrabarpersist hrLo[30000](999999),
	intrabarpersist hrVol[30000](0);

begin
	[ProcessMouseEvents = True];
	[IntrabarOrderGeneration = True];
	
	if MouseClickCtrlPressed then 
	begin 
		print("log enabled");
		logEnable=True;
	end;
	if MouseClickShiftPressed then
	begin
		print("log disabled");
		logEnable=False;
	end;

	myGetDayIndex(daybarindex);
	myGetFullDayData(dayOpen, dayClose, dayHi, dayLo, dayBarIndex);
	
	last10mStart = myGet10mIndex(m10BarIndex);
	myGet10mData(m10Close, m10Hi, m10Lo, m10Vol, m10BarIndex);
	
	myGetHrIndex(hrBarIndex);
	myGetHrData(hrClose, hrHi, hrLo, hrVol, hrBarIndex);
	
	powerVal[hrBarIndex] = myPowerIndex(hrVol[hrBarindex], hrClose[hrBarIndex], hrClose[hrBarIndex-1]);
	myXAverage(powerVal[hrBarIndex], powerShortPeriod, hrBarIndex, powerShortEma);
	myXAverage(powerVal[hrBarIndex], powerLongPeriod, hrBarIndex, powerLongEma);
	
	recentHiPowerIndex = myExtremesArray(powerShortEma, hrBarIndex, true, powerIndexExtremeLen);
	recentLoPowerIndex = myExtremesArray(powerShortEma, hrBarIndex, false, powerIndexExtremeLen);
	
	recentHi = myExtremesArray(m10Hi, m10BarIndex, true, recentHiLoWide);
	recentLo = myExtremesArray(m10Lo, m10BarIndex, false, recentHiLoWide);
	
	theTR[hrBarIndex] = myTR(hrHi, hrLo, hrClose, hrBarIndex);
	myXAverage(theTR[hrBarIndex], atrMa, hrBarIndex, theATR);
	
	dir = myMADir(dayClose[dayBarIndex], trendEmaShortPeriod, trendEmaLongPeriod, mindelta, fastDayMA, slowDayMA, dayBarIndex);
	
	if not unfinishedTrade then tradeDir = marketposition();
	
	//will not open twice in a same hour bar
	if tradeDir = 0 and Time > timeBlank and hrBarIndex>lastTradeIndex then
	begin
	//	if dir = 1 and powerShortEma[hrBarIndex]>0 and powerShortEma[hrBarIndex] = recentHiPowerIndex then
	//	begin
	//		openPoint = hrHi[hrBarIndex-1]+openBreak*MinMove/PriceScale;
	//		tempRiskPoint = Close + slide*MinMove/PriceScale - (recentLo-2*slide*MinMove/PriceScale);
	//		if Close >= openPoint and tempRiskPoint<maxRiskPoint then // we could try cross over here
	//		begin
	//			buy tradeShares share at next bar at market;
	//			myLogTradeInfo(hrbarindex, "buy at market", logenable);
	//			lastTradeIndex = hrBarIndex;
	//			newExtremeCnt = 0;
	//			stopPrice = 0;
	//		end;
	//	end;
		
		if dir = -1 and powerShortEma[hrBarIndex]<0 and powerShortEma[hrBarIndex] = recentLoPowerIndex then
		begin
			openPoint = hrLo[hrBarIndex-1]-openBreak*MinMove/PriceScale;
			tempRiskPoint = recentHi+2*slide*MinMove/PriceScale - (Close-slide*MinMove/PriceScale);
			if Close <= openPoint and tempRiskPoint<maxRiskPoint then
			begin
				sellshort tradeShares share at next bar at market;
				myLogTradeInfo(hrbarindex, "sell short at market", logenable);
				lastTradeIndex = hrBarIndex;
				newExtremeCnt = 0;
				stopPrice = 0;
			end;
		end;
	end;
	
	// updating stop price when it's in the same hour har
//	if lastTradeIndex=hrBarIndex and tradeDir=1 then
//	begin
//		stopPrice = recentLo - 1*MinMove/PriceScale;
//		if stopPrice<stopPrice[1] then newExtremeCnt = newExtremeCnt+1;
//		if newExtremeCnt >= 3 then sell("too many new low") at next bar at market; 
//		//Arw_New (date, time, stopPrice, true); 
//	end;
	if lastTradeIndex=hrbarindex and tradeDir=-1 then
	begin
		stopPrice = recentHi + 1*MinMove/PriceScale;
//		if stopPrice>stopPrice[1] then newExtremeCnt = newExtremeCnt+1;
//		if newExtremeCnt >= 3 then buytocover("too many new high") at next bar at market;
		//Arw_New (date, time, stopPrice, false);
	end;
	
	if not unfinishedTrade then 
	begin
		// check market position
		tradeDir = marketposition;
		// check entry price
		startPrice = avgentryprice;
	end;
	
	// sell close judge
//	if tradeDir=1 and startPrice<>0 and m10BarIndex>=lastTradeIndex then
//	begin
//		virtualProfit = m10Lo[m10BarIndex-1] - slide*MinMove/PriceScale - startPrice;
//		if virtualProfit>=0 then winFlag = true;
//		if winFlag = true then
//		begin
//			// if still making money
//			if Close>= m10Lo[m10BarIndex-1] then tl_new(date, floor(time/100)*100, m10Lo[m10BarIndex-1], date, time, m10Lo[m10BarIndex-1])
//			else // otherwise get out
//			begin
//				winFlag=False;
//				lastTradeIndex=m10BarIndex;
//				sell("stop win sell") at next bar at market;
//				myLogTradeInfo(m10barindex, "stop win sell", logenable);
//				unfinishedTrade = False;
//			end;
//		end
//		else // if it did not make any profit yet, calculate stop lose point
//		begin
//			if lastAtrHour<m10BarIndex then 
//			begin
//				stopPrice=stopPrice+theATR[m10BarIndex-1]*atrIndex;
//				lastAtrHour=m10BarIndex;
//			end;
//			tl_new(date, floor(time/100)*100, stopPrice, date, time, stopPrice);
//		end;
//		// stop lose judge
//		if close <= stopPrice then
//		begin
//			winFlag=False;
//			lastTradeIndex = m10BarIndex;
//			sell("stop lose sell") at next bar at market;
//			myLogTradeInfo(m10barindex, "stop lose sell", logenable);
//			unfinishedTrade = False;
//		end;
//	end;
	
	// buy to cover close
	if tradeDir=-1 and startPrice<>0 and m10BarIndex>=lastTradeIndex then
	begin
		virtualProfit = startPrice - m10Hi[m10BarIndex-1] - slide*MinMove/PriceScale;
		if virtualProfit>=0 then winFlag = true;
		if winFlag = true then
		begin
			// if still making money
			if Close <= m10Hi[m10BarIndex-1] then tl_new(date, last10mStart, m10Hi[m10BarIndex-1], date, time, m10Hi[m10BarIndex-1])
			else // otherwise get out
			begin
				winFlag=False;
				lastTradeIndex=m10BarIndex;
				buytocover("stop win buy") at next bar at market;
				myLogTradeInfo(m10barindex, "stop win buy to cover", logenable);
				unfinishedTrade = False;
			end;
		end
		else // if it did not make any profit yet, calculate stop lose point
		begin
			if lastAtrHour<m10BarIndex then 
			begin
				stopPrice=stopPrice-theATR[m10BarIndex-1]*atrIndex;
				lastAtrHour=m10BarIndex;
			end;
			tl_new(date, last10mStart, stopPrice, date, time, stopPrice);
		end;
		// stop lose judge
		if Close >= stopPrice then
		begin
			winFlag=False;
			lastTradeIndex = m10BarIndex;
			buytocover("stop lose buy") at next bar at market;
			myLogTradeInfo(m10barindex, "stop lose buy to cover", logenable);
			unfinishedTrade = False;
		end;
	end;
	
	// safety net
	if m10BarIndex>=lastTradeIndex then
	begin
//		if tradeDir=1 and startPrice-Close>maxRiskPoint then 
//		begin 
//			sell("safety net sell") at next bar at market;
//			myLogTradeInfo(m10barindex, "safety net sell", logenable);
//			unfinishedTrade = False;
//		end;
		if tradeDir=-1 and Close-startPrice>maxRiskPoint then 
		begin
			buytocover("safety net buy") at next bar at market;
			myLogTradeInfo(m10barindex, "safety net buy to cover", logenable);
			unfinishedTrade = False;
		end;
	end;
end
	
