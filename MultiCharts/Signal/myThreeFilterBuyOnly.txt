inputs: 
	trendEmaLongPeriod(15),// trend EMA long period
	trendEmaShortPeriod(2), // trend EMA short period
	minDelta(10),// threshold by exceeding which a trend could be recognized
	
	powerLongPeriod(12), // power index EMA long period
	powerShortPeriod(5), // power index EMA short period
	powerIndexExtremeLen(5), // power index EMA extreme period
	
	maxRiskPoint(30),// max possible lose
	tradeShares(1),// trade shares
	
	cost(0),// cost rate
	minVolumn(10),// min trade amount
	
	realTrade(false),
	
	timeBlank(903),
	openBreak(1),
	recentHiLoWide(2),// recent hi/lo period
	slide(1),// open slide
	atrIndex(0.1),// the coefficient that translate atr into price
	atrMa(1),// ATR MA period
	
	logSwitch(True),// enable or disable log
	
	existingTrade(false),
	existingLastTradeHour(0),// can specify existing trade bar index
	existingTradeDir(0),// can specify existing position before 
	existingStartPrice(0);// can specify existing entry price

vars:
	intrabarpersist newExtremeCnt(0),
	intrabarpersist unfinishedTrade(existingTrade),
	intrabarpersist tradeDir(existingTradeDir),
	intrabarpersist auxTradeDir(0),
	intrabarpersist stopPrice(0),
	intrabarpersist startPrice(existingStartPrice),
	intrabarpersist endPrice(False),
	intrabarpersist winFlag(False),
	intrabarpersist win(0),
	intrabarpersist lose(0),
	intrabarpersist dir(0),
	intrabarpersist lastTradeDate(0),
	intrabarpersist lastTradeHour(existingLastTradeHour),
	intrabarpersist lastAtrHour(0),
	intrabarpersist lastAtrDate(0),
	intrabarpersist lastSerializeMin(0),
	intrabarpersist dayBarIndex(10),
	intrabarpersist hrBarIndex(0),
	intrabarpersist recentLo(0),
	intrabarpersist recentHi(0),
	intrabarpersist openPoint(0),
	intrabarpersist virtualProfit(0),
	intrabarpersist tempVal(0),
	intrabarpersist recentHiPowerIndex(0),
	intrabarpersist recentLoPowerIndex(0),
	intrabarpersist tempRiskPoint(0),
	intrabarpersist myProfit(0),
	intrabarpersist logEnable(logSwitch);
array: 
	intrabarpersist fastDayMA[1000](close),
	intrabarpersist slowDayMA[1000](close),
	intrabarpersist dayOpen[1000](close),
	intrabarpersist dayClose[1000](close),
	intrabarpersist dayHi[1000](0),
	intrabarpersist dayLo[1000](999999),
	intrabarpersist powerShortEma[5000](0), 
	intrabarpersist powerLongEma[5000](0),
	intrabarpersist powerVal[5000](0),
	intrabarpersist theATR[5000](0),
	intrabarpersist theTR[5000](0),
	intrabarpersist hrClose[5000](0),
	intrabarpersist hrHi[5000](0),
	intrabarpersist hrLo[5000](999999),
	intrabarpersist hrVol[5000](0);

begin
	[ProcessMouseEvents = True];
	[IntrabarOrderGeneration = False];
	
	if MouseClickCtrlPressed then 
	begin 
		print("log enabled");
		logEnable=True;
	end;
	if MouseClickShiftPressed then
	begin
		print("log disabled");
		logEnable=False;
	end;

	myGetDayIndex(daybarindex);
	myGetFullDayData(dayOpen, dayClose, dayHi, dayLo, dayBarIndex);
	//myGetDayData(dayClose, dayHi, dayLo, dayBarIndex);

	myGetHrIndex(hrBarIndex);	
	myGetHrData(hrClose, hrHi, hrLo, hrVol, hrBarIndex);
	
	powerVal[hrBarIndex] = myPowerIndex(hrVol[hrBarindex], hrClose[hrBarIndex], hrClose[hrBarIndex-1]);
	myXAverage(powerVal[hrBarIndex], powerShortPeriod, hrBarIndex, powerShortEma);
	myXAverage(powerVal[hrBarIndex], powerLongPeriod, hrBarIndex, powerLongEma);
	
	recentHiPowerIndex = myExtremesArray(powerShortEma, hrBarIndex, true, powerIndexExtremeLen);
	recentLoPowerIndex = myExtremesArray(powerShortEma, hrBarIndex, false, powerIndexExtremeLen);
	
	recentHi = myExtremesArray(hrHi, hrBarIndex, true, recentHiLoWide);
	recentLo = myExtremesArray(hrLo, hrBarIndex, false, recentHiLoWide);
	
	theTR[hrBarIndex] = myTR(hrHi, hrLo, hrClose, hrBarIndex);
	myXAverage(theTR[hrBarIndex], atrMa, hrBarIndex, theATR);
	
	dir = myMADir(dayClose[dayBarIndex], trendEmaShortPeriod, trendEmaLongPeriod, mindelta, fastDayMA, slowDayMA, dayBarIndex);
	
	if not unfinishedTrade then tradeDir = marketposition();
	
	//will not open twice in a same hour bar
	if tradeDir = 0 and Time > timeBlank and hrBarIndex>lastTradeHour then
	begin
		if dir = 1 and powerShortEma[hrBarIndex]>0 and powerShortEma[hrBarIndex] = recentHiPowerIndex then
		begin
			openPoint = hrHi[hrBarIndex-1]+openBreak*MinMove/PriceScale;
			tempRiskPoint = Close + slide*MinMove/PriceScale - (recentLo-2*slide*MinMove/PriceScale);
			if Close >= openPoint and tempRiskPoint<maxRiskPoint*MinMove/PriceScale then // we could try cross over here
			begin
				buy tradeShares share at next bar at market;
				myLogTradeInfo(hrbarindex, "buy at market", logenable);
				lastTradeHour = hrBarIndex;
				newExtremeCnt = 0;
				stopPrice = 0;
			end;
		end;
		
	//	if dir = -1 and powerShortEma[hrBarIndex]<0 and powerShortEma[hrBarIndex] = recentLoPowerIndex then
	//	begin
	//		openPoint = hrLo[hrBarIndex-1]-openBreak*MinMove/PriceScale;
	//		tempRiskPoint = recentHi+2*slide*MinMove/PriceScale - (Close-slide*MinMove/PriceScale);
	//		if Close <= openPoint and tempRiskPoint<maxRiskPoint*MinMove/PriceScale then
	//		begin
	//			sellshort tradeShares share at next bar at market;
	//			myLogTradeInfo(hrbarindex, "sell short at market", logenable);
	//			lastTradeHour = hrBarIndex;
	//			newExtremeCnt = 0;
	//			stopPrice = 0;
	//		end;
	//	end;
	end;
	
	// updating stop price when it's in the same hour har
	if lastTradeHour=hrBarIndex and tradeDir=1 then
	begin
		stopPrice = recentLo - 1*MinMove/PriceScale;
		if stopPrice<stopPrice[1] then newExtremeCnt = newExtremeCnt+1;
		if newExtremeCnt >= 3 then sell("too many new low") at next bar at market; 
		//Arw_New (date, time, stopPrice, true); 
	end;
//	if lastTradeHour=hrbarindex and tradeDir=-1 then
//	begin
//		stopPrice = recentHi + 1*MinMove/PriceScale;
//		if stopPrice>stopPrice[1] then newExtremeCnt = newExtremeCnt+1;
//		if newExtremeCnt >= 3 then buytocover("too many new high") at next bar at market;
//		//Arw_New (date, time, stopPrice, false);
//	end;
	
	if not unfinishedTrade then 
	begin
		// check market position
		tradeDir = marketposition;
		// check entry price
		startPrice = avgentryprice;
	end;
	
	// sell close judge
	if tradeDir=1 and startPrice<>0 and hrBarIndex>=lastTradeHour then
	begin
		virtualProfit = hrLo[hrBarIndex-1] - slide*MinMove/PriceScale - startPrice;
		if virtualProfit>=0 then winFlag = true;
		if winFlag = true then
		begin
			// if still making money
			if Close>= hrLo[hrBarIndex-1] then tl_new(date, floor(time/100)*100, hrLo[hrBarIndex-1], date, time, hrLo[hrBarIndex-1])
			else // otherwise get out
			begin
				winFlag=False;
				lastTradeHour=hrBarIndex;
				sell("stop win sell") at next bar at market;
				myLogTradeInfo(hrbarindex, "stop win sell", logenable);
				unfinishedTrade = False;
			end;
		end
		else // if it did not make any profit yet, calculate stop lose point
		begin
			if lastAtrHour<hrBarIndex then 
			begin
				stopPrice=stopPrice+theATR[hrBarIndex-1]*atrIndex;
				lastAtrHour=hrBarIndex;
			end;
			tl_new(date, floor(time/100)*100, stopPrice, date, time, stopPrice);
		end;
		// stop lose judge
		if close <= stopPrice then
		begin
			winFlag=False;
			lastTradeHour = hrBarIndex;
			sell("stop lose sell") at next bar at market;
			myLogTradeInfo(hrbarindex, "stop lose sell", logenable);
			unfinishedTrade = False;
		end;
	end;
	
	// buy to cover close
//	if tradeDir=-1 and startPrice<>0 and hrBarIndex>=lastTradeHour then
//	begin
//		virtualProfit = startPrice - hrHi[hrBarIndex-1] - slide*MinMove/PriceScale;
//		if virtualProfit>=0 then winFlag = true;
//		if winFlag = true then
//		begin
//			// if still making money
//			if Close <= hrHi[hrBarIndex-1] then tl_new(date, floor(time/100)*100, hrHi[hrBarIndex-1], date, time, hrHi[hrBarIndex-1])
//			else // otherwise get out
//			begin
//				winFlag=False;
//				lastTradeHour=hrBarIndex;
//				buytocover("stop win buy") at next bar at market;
//				myLogTradeInfo(hrbarindex, "stop win buy to cover", logenable);
//				unfinishedTrade = False;
//			end;
//		end
//		else // if it did not make any profit yet, calculate stop lose point
//		begin
//			if lastAtrHour<hrBarIndex then 
///			begin
//				stopPrice=stopPrice-theATR[hrBarIndex-1]*atrIndex;
//				lastAtrHour=hrBarIndex;
//			end;
//			tl_new(date, floor(time/100)*100, stopPrice, date, time, stopPrice);
//		end;
//		// stop lose judge
//		if Close >= stopPrice then
//		begin
//			winFlag=False;
//			lastTradeHour = hrBarIndex;
//			buytocover("stop lose buy") at next bar at market;
//			myLogTradeInfo(hrbarindex, "stop lose buy to cover", logenable);
//			unfinishedTrade = False;
//		end;
//	end;
	
	// safety net
	if hrBarIndex>=lastTradeHour then
	begin
		if tradeDir=1 and startPrice-Close>maxRiskPoint*MinMove/PriceScale then 
		begin 
			sell("safety net sell") at next bar at market;
			myLogTradeInfo(hrbarindex, "safety net sell", logenable);
			unfinishedTrade = False;
		end;
//		if tradeDir=-1 and Close-startPrice>maxRiskPoint*MinMove/PriceScale then 
//		begin
//			buytocover("safety net buy") at next bar at market;
//			myLogTradeInfo(hrbarindex, "safety net buy to cover", logenable);
//			unfinishedTrade = False;
//		end;
	end;
end
	
